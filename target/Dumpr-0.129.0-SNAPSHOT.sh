#!/bin/bash
# ---------------------------------------------
# Artifact:     Dumpr/Dumpr
# Version:      0.129.0-SNAPSHOT
# Date (UTC):   sÃ¡b jun 22 08:40:46 UTC 2013
# Generated by: bashing 0.1.6
# ---------------------------------------------
export __BASHING_VERSION='0.1.6'
export __VERSION='0.129.0-SNAPSHOT'
export __ARTIFACT_ID='Dumpr'
export __GROUP_ID='Dumpr'
function configParse() {
    for line in `cat $1`; do
        key=${line%%=*};
        value=${line##*=};
        case    $key in
            proxy)
                proxy=$value;
            ;;
            port)
                port=$value;
            ;;
            proto)
                proto=$value;
            ;;
        esac;
    done;
    [[ ! $proxy || ! $port || ! $proto ]] &&  ( return 1 );
    proxy_port="$proxy:$port";
}
function configLoad() {
	if [[ -e $conf ]]; then
	    configParse $conf;
	    case    $? in
	        1)
	            log "Error loading configuration. Bad configuration file." $alerts;
	            exit 1;
	        ;;
	        *)
	            log "Configuration file '$conf' loaded.";
	        ;;
	    esac;
	else
	    log "Warning: No proxy configuration loaded." $alerts;
	fi;
}
function log {
    (( ! $quiet )) && echo $1;
    (( $2 )) && `kdialog --title ${const.default.alert.title} --passivepopup "$1"`;
    (( $log )) && echo "[`date`] [ $logfilename ] $1" >> $logfilename;
}
function usage {
    cat $USAGE_FILE
}
function initialize {
    items=$1;
    total=${#items[@]};
    (( !$length )) && length=$total;
}
function showsettings {
    if [[ ! $proxy_port ]]; then
        proxy_setting="(No proxy)";
    else
        proxy_setting=$proxy_port;
    fi;
    if (( $log )); then
        logginfile=$logfilename;
    else
        logginfile="(No loggin)";
    fi;
    if [[ $params ]]; then
        curlparams=$params;
    else
        curlparams="(No user params)";
    fi;
    if [[ -e $conf ]]; then
        configuration=$conf;
    else
        configuration="(No configuration)";
    fi;
    cat <<-EOF;
    Settings:
        Task list           : $src
        Type                : $type
        Destination         : $dest
        Configuration       : $configuration
        Proxy               : $proxy_setting
        Retries             : $retry
        Recursion           : $recursive
        Recursion depth     : $recursion_depth
        Curl params         : $curlparams
        Loggin file         : $logginfile
        Task list item(s)   : $total
    Download list:
EOF
    listItems $items;
cat <<-EOF
    Total $total item(s) queued for download.
    Download started: `date`;
EOF
}
DEF_LIST_NAME=download.lst
DEF_TMP_PATH=/tmp/
DEF_TMP_NAME=.dumpr-$RANDOM
TMP_LIST=$DEF_TMP_PATH$DEF_LIST_NAME-$RANDOM
HELPER_PATH=~/.dumpr/share/helpers.pl
BANNER=~/.dumpr/share/banner.sh
BUILD_TIME="vie jun 21 22:17:23 ART 2013"
VERSION_NUMBER=0.129.0
src=download.lst
type=list
dest=$PWD
conf=~/.dumpr/share/conf-default
retry=10
recursive=1
recursion_depth=2
log=0
quiet=0
logfilename=log
offset=0
length=0
alerts=0
proxy_port=""
update=0
timestamp=0
function listItems {
    i=0;
    items=$1;
    for item in ${items[@]}; do
        log "[$i] $item";
        let i++;
    done;
}
function listCheck {
    if [[ -e $1 ]]; then
        if [ "`wc -l $1 | cut -d' ' -f1`" == "0" ]; then
            return 2;
        fi;
    else
        return 1;
    fi;
}
function listParse {
    i=0;
    for item in `cat $1`; do
        items[i]=$item;
        let i++;
    done;
}
function listLoad {
    `curl $params $proto $proxy_port  -s --output "$DEF_TMP_NAME" --retry $retry $1`; # it's a directory so it needs a trailing slash or you will get 301
    if (( ! $? )); then # $? == 0
        list=`"${const.default.helper.path}" list "$DEF_TMP_NAME"`;
        for url in $list; do
            if [[ $url =~ (.*\/)$ ]]; then # a directory: .*/
                case $url in
                    "../" | "./" | "/") # meta directories
                    ;;
                    *)
                        (( $recursive )) && ( retrivelist $1$url $2);
                    ;;
                esac;
            else
                echo "$1$url" >> $2;  # This is weak as some listing may display full paths.
            fi;
        done;
        return 0;
    else
        [[ -e "$DEF_TMP_NAME" ]] && ( rm "$DEF_TMP_NAME" );
        return 1;
    fi;
}
function listInitialize() {
    case    "$type" in
        remote | create-list)
            log "Retrieving remote list...";
            :>$TMP_LIST; # cleaning out download list
            listLoad "$src/" "$TMP_LIST";
            case    !? in
                0)
                    log "Remote list retrieved successfully.";
                ;;
                1)
                    log "Error retrieving remote list. Aborting." $alerts;
                    exit 1;
                ;;
            esac;
            src=$TMP_LIST;
            checklist $src;
            if (( $? )); then # $? != 0
                log "Error retrieving download list. Aborting." $alerts;
                exit 1;
            fi;
            if [[ $type == "create-list" ]]; then
                log "List successfully created.";
                cat $src;
                exit 0;
            fi;
        ;;
        list)
            checklist $src;
            case    $? in
                1)
                    log "No list found on '$src'. Aborting." $alerts;
                    exit 1;
                ;;
                2)
                    log "Empty download list '$src'. Aborting." $alerts;
                    exit 2;
                ;;
                0)
                    log "List file '$src' loaded.";
                ;;
            esac;
        ;;
        file)
            echo $src > $TMP_LIST;
            src=$TMP_LIST;
        ;;
    esac;
}
function paramsParse() {
    while [[ $1 ]]; do
        case    $1 in
            -l=* | --list=*)    # Will take the list of files to download from a local file.
                src=${1##*=};
                type="list";
            ;;
            -u=* | --url=*)     # Will retrieve the list from a remote directory listing.
                src=${1##*=};
                src=${src%%\/}; # stripping training slash.
                base=$src;
                type="remote";
            ;;
            -f=* | --file=*)    # Will download a single file.
                recursive=0;
                src=${1##*=};
                type="file";
            ;;
            -o=* | --offset=*)  # offset in the format: from,len
                offsets=${1##*=};
                offset=${offsets%%,*};
                length=${offsets##*,};
                (( !$offset )) && offset=0;
                (( !$length )) && length=0;
            ;;
            --alerts)           # Use alerts for finished, failed etc, downloads.
                alerts=1;
            ;;
            -lo | --list-only)
                type="create-list";
            ;;
            -r=* | --recursive=* )
                recursive=${1##*=};#true or false
            ;;
            -b=* | --base=*)    # Base url when using recursive listing.
                base=${1##*=};
                base=${base%%\/}
            ;;
            -d=* | --dest=*)    # By default it uses the current directory.
                dest=${1##*=};
                dest=${dest%%\/}
            ;;
            -c=* | --config=* | --conf=*)  # Will read proxy configuration from a file.
                conf=${1##*=};
            ;;
            -r=* | --retry=*)   # Retry count. Default 10.
                retry=${1##*=};
            ;;
            --params=*)         # Custom params passed to curl.
                params=${1##*=};
            ;;
            --quiet)            # No banner
                quiet=1;
                verbosity=0;
            ;;
            --log)              # Log debug strings to file
                log=1;
            ;;
            -md5 | --hash)      # Perform an Md5 hash over the downloaded files.
                hash=1;
            ;;
            -x=* | --on-complete=*) # Launch a determined script or binary on download completion.
                launch=${1##*=};
            ;;
            --update)  # Update list items as the file list is changed
                update=1;
            ;;
            -h | --help)        # Display help information.
                usage;
                exit 0;
            ;;
            -v | --version)     # Display version information.
                $ already displayed into the banner
                exit 0;
            ;;
        esac;
        shift;
    done;
}
function usage() {
  cat <<EOF
                         8888888b.                                          
                         888  "Y88b                                         
                         888    888                                         
                         888    888 888  888 88888b.d88b.  88888b.  888d888 
                         888    888 888  888 888 "888 "88b 888 "88b 888P"   
                         888    888 888  888 888  888  888 888  888 888     
                         888  .d88P Y88b 888 888  888  888 888 d88P 888     
                         8888888P"   "Y88888 888  888  888 88888P"  888     
                                                           888              
                         Download manager/queue downloader 888              
                                                           888              
EOF
echo 
cat <<EOF
   ./dumpr.sh --url|--file|--list url|list [--dest][--config][--create-list][--retry][--hash][--on-complete]
EOF
echo 
cat <<EOF
 Example:
   ./dumper.sh --list=list.txt --dest=~/downloads/dest
EOF
echo 
cat <<EOF
   Will open 'list.txt' on current directory to read its contents.
   From 'list.txt' the script will take the items to download.
EOF
echo 
cat <<EOF
   '~/downloads/dest' is the destination directory for the downloaded files.
EOF
echo 
cat <<EOF
   --list-only: Only download the directory listing (--url) and create a download list.
   --config: Point to the configuration file.
   --alerts: Display alets on download complete.
   --quiet: Don't show any message.
   --param: Params to pass to Curl.
   --retry: Retry attempts.
   --hash: If make an md5 hash of the downloaded items.
   --on-complete: Executes a program or script, or commands, on download completion.
   --update: Update download list as it changes on disk (--list).
   --log: Enables logging to file.
EOF
echo 
cat <<EOF
 More examples:
   asphyxia@dev$ dumpr.sh --url=http://localhost/music/ --dest=~/downloads/music/
EOF
echo 
cat <<EOF
   Build time: $BUILD_TIME
   Version: $VERSION_NUMBER
EOF
echo 
}
function cli_download() {
(( ! $# )) && usage && exit
paramsParse $* && configLoad
listInitialize
(( ! $quiet )) && [[ -e BANNER ]] && cat $BANNER
[[ $type == "list" && ! -e $src ]] && echo "File list doesn't exists!: $src" && exit
listParse $src
timestamp=$(stat --printf "%Y" "$src");
[[ $timestamp == 0 ]] && echo "Can't read file list!" && exit
success=0; failed=0; total=0; $downloaded_items;
total=${#items[@]};
(( !$length )) && length=$total;
(( !$quiet )) && showsettings;
while (( 1 )); do
    url=${items[$offset]};
    for try in `seq 1 $retry`; do
        log "Downloading $url ($try)";
        if (( $try == 1 )); then
            filename=`$HELPER_PATH filename $url`;
            filename=`$HELPER_PATH decode $filename`;
            if (( $recursive )); then
                relative_path=`$HELPER_PATH relative-path $base $url`;
                relative_path=`$HELPER_PATH decode "$relative_path"`;
                if [[ ! -e "$dest/$relative_path" ]]; then
                    log "Creating directory: '$dest/$relative_path'...";
                    mkdir -p "$dest/$relative_path";
                fi;
            fi;
            downloaded_items="$downloaded_items '$dest/$relative_path/$filename'";
        fi;
        `curl $params $proto $proxy_port  --output "$dest/$relative_path/$filename" -C - --retry $retry "$url"`;
        if (( ! $? )); then
            break;
        fi;
    done;
    if (( $try == $retry )); then
        echo $url >> "$dest/failed";
        log "Download failed: $url" $alerts;
        let failed++;
    else
        echo "$dest/$filename">>"$dest/success";
        log "Download complete: $url" $alerts;
        let success++;
    fi;
    log "$success successful downloads. $failed failed. $success/$total items downloaded.";
    (( ! $quiet )) && echo;
    if [[ $launch ]]; then
        field=1;
        while [[ "`echo $launch | cut -s -d";" -f$field`" != "" ]]; do
            command=`echo $launch | cut -s -d";" -f$field`;
            eval $command;
            let field++;
        done;
    fi;
    if [[ $update ]]; then
        if [[ $type == 'list' ]]; then
            tsupdate=$(stat --printf '%Y' $src);
            if [[ $timestamp != $tsupdate ]]; then
                log 'Updating list file';
                items=();
                listParse "$src";
                listItems $items;
                log '';
                total=${#items[@]};
                length=$total;
                timestamp=$tsupdate;
            fi;
        fi;
    fi;
    let offset++;
    if (( $offset >= $total )); then
        break;
    fi;
done;
if (( $hash )); then
    log "MD5 of downloads:";
    log `md5sum $downloaded_items | tee -a "$dest/md5s"`;
fi;
[[ -e $TMP_LIST ]] && rm $TMP_LIST;
log "Script finished. `date`" $alerts;
exit $failed;
  return 0;
}
function cli_usage() {
usage
  return 0;
}
function __run() {
  local pid=""
  local status=255
  local cmd="$1"
  shift
  case "$cmd" in
    "") __run "help"; return $?;;
    "download") cli_download "$@" & local pid="$!";;
    "usage") cli_usage "$@" & local pid="$!";;
    "help")
      echo "Usage: Dumpr <task> [...]" 1>&2
      cat 1>&2 <<HELP

    download  :  (no help available)
    help      :  display this help message
    usage     :  (no help available)
    version   :  display version

HELP
      status=0
      ;;
    "version")
      echo "Dumpr 0.129.0-SNAPSHOT (bash $BASH_VERSION)"
      status=0
      ;;
    *) echo "Unknown Command: $cmd" 1>&2;;
  esac
  if [ ! -z "$pid" ]; then
      wait "$pid"
      local status=$?
  fi
  return $status
}
__run "$@"
export __STATUS="$?"
exit $__STATUS
